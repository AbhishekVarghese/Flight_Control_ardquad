#include <Wire.h>



int gyro_x, gyro_y, gyro_z;

long acc_x, acc_y, acc_z, acc_total_vector;

long gyro_x_cal, gyro_y_cal, gyro_z_cal;

long loop_timer;

int lcd_loop_counter;

float angle_pitch, angle_roll;

int angle_pitch_buffer, angle_roll_buffer;

boolean set_gyro_angles;

float angle_roll_acc, angle_pitch_acc;

float angle_pitch_output, angle_roll_output;





void setup()
{
  Wire.begin();  
   Serial.begin(57600);
 
  setup_mpu_6050_registers(); 

   digitalWrite(13, HIGH);   

   
   delay(1500);   

   
  for (int cal_int = 0; cal_int < 2000 ; cal_int ++)
   {        read_mpu_6050_data();  
    gyro_x_cal += gyro_x; 

    gyro_y_cal += gyro_y; 

    gyro_z_cal += gyro_z; 

    delay(3);             
   }

  gyro_x_cal /= 2000; 

  gyro_y_cal /= 2000; 

  gyro_z_cal /= 2000; 
  digitalWrite(13, LOW); 

  
loop_timer = micros();   

}



void loop()
{

  read_mpu_6050_data();   


   gyro_x -= gyro_x_cal;  
   gyro_y -= gyro_y_cal;   
   gyro_z -= gyro_z_cal;   

  
  //Gyro angle calculations

  angle_pitch += gyro_x * 0.0000611;
  angle_roll += gyro_y * 0.0000611;  

 //0.000001066 = 0.0000611 * (3.142(PI) / 180degr) 
  angle_pitch += angle_roll * sin(gyro_z * 0.000001066);
  angle_roll -= angle_pitch * sin(gyro_z * 0.000001066); 
 
  //Accelerometer angle calculations

  acc_total_vector = sqrt((acc_x*acc_x)+(acc_y*acc_y)+(acc_z*acc_z));  
//Calculate the total accelerometer vector
  //57.296 = 1 / (3.142 / 180) 

  angle_pitch_acc = asin((float)acc_y/acc_total_vector)* 57.296;       

  angle_roll_acc = asin((float)acc_x/acc_total_vector)* -57.296;       

  
 
  angle_pitch_acc -= 0.0;  
//Accelerometer calibration value for pitch
  
  angle_roll_acc -= 0.0; 
  //Accelerometer calibration value for roll


if(set_gyro_angles)
{  //If the IMU is already started
    
    angle_pitch = angle_pitch * 0.9996 + angle_pitch_acc * 0.0004;

    angle_roll = angle_roll * 0.9996 + angle_roll_acc * 0.0004;   
}
 
else{//at  start

     angle_pitch = angle_pitch_acc;   
     angle_roll = angle_roll_acc;   
 
    set_gyro_angles = true; 
    }
 
 
  //To dampen the pitch and roll angles a complementary filter is used
 
  angle_pitch_output = angle_pitch_output * 0.9 + angle_pitch * 0.1;   
//Take 90% of the output pitch value and add 10% of the raw pitch value
  
  angle_roll_output = angle_roll_output * 0.9 + angle_roll * 0.1;      
//Take 90% of the output roll value and add 10% of the raw roll value
  
  

while(micros() - loop_timer < 4000); 
   //Wait until the loop_timer reaches 4000us (250Hz) before starting the next loop
  
    loop_timer = micros(); 
 //Reset the loop timer

}



void read_mpu_6050_data()
{   
 Wire.beginTransmission(0x68);      
 Wire.write(0x3B);  
 Wire.endTransmission();
 Wire.requestFrom(0x68,14);
  while(Wire.available() < 14);
  acc_x = Wire.read()<<8|Wire.read();
  acc_y = Wire.read()<<8|Wire.read();  
  acc_z = Wire.read()<<8|Wire.read();


  Wire.read();//these 16 bits are for temperature measurement
  Wire.read();    
gyro_x = Wire.read()<<8|Wire.read(); 
 gyro_y = Wire.read()<<8|Wire.read();  
 gyro_z = Wire.read()<<8|Wire.read(); 
}





void setup_mpu_6050_registers()
{
  //Activate the MPU-6050
  
Wire.beginTransmission(0x68);                                        
//Start communicating with the MPU-6050
  
Wire.write(0x6B);                                                    
//Send the requested starting register
  
Wire.write(0x00); 
//Set the requested starting register
  
Wire.endTransmission();      
//End the transmission
  
//Configure the accelerometer (+/-8g)
  
Wire.beginTransmission(0x68);
//Start communicating with the MPU-6050
  
Wire.write(0x1C);  
//Send the requested starting register
  
Wire.write(0x10); 
//Set the requested starting register
  
Wire.endTransmission();  
//End the transmission
  //Configure the gyro (500dps full scale)
  
Wire.beginTransmission(0x68);     
//Start communicating with the MPU-6050
  
Wire.write(0x1B);
//Send the requested starting register
  
Wire.write(0x08);
//Set the requested starting register
  
Wire.endTransmission(); 
//End the transmission

}














